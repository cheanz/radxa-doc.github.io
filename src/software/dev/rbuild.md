# rbuild

## Folder structure
```
.github/            GitHub workflow related files.
.rootfs/            Untracked folder containing rootfs generated by the last build.
                    Can be used to speed up image generation the next time.

common/             rbuild scripts
    .packages/      Untracked folder for soft linking local packages
    flavors/        Package lists for various supported flavors
    overlays/       Various overlays for directly applying onto rootfs
    add_repo.yaml   Adding custom apt repo in rootfs
    clean.yaml      Common clean up script
    hack_install_deb.yaml
                    HACK for installing local package.
                    Only for debug use. Repo should not contain prebuild deb packages.
    hw-info.conf    Stores SoC's vendor and each vendor's preferred partition table type.
    image.yaml      Core script for deploying a rootfs to disk image.
                    Also install device specific kernel and firmware.
    rootfs.sh       Prepare the system for first boot.
    rootfs.yaml     Core script for generating a device-agnostic rootfs.
    sdboot.sh       Additional script for setting systemd-boot.

.gitignore          gitignore file
configs/            Board specific configs.
docs/               Documentation.
action.yaml         GitHub custom action file. Allow this repo to be used in GitHub Workflow.
rbuild              Main script.
README.md           Project readme.
```

## How to add new boards?
Enabling new board in rbuild is simple, as most jobs should have already been done before touching this repo.

You should first update [`lbuild`](./lbuild.md) and [`ubuild`](./ubuild.md) to have them generate `linux-images-<board-name>` and `u-boot-<board-name>` deb packages. Do not mismatch those packages with different boards as the script might call files under board specific folder. In case of Linux kernel the package's name should not be touched, and `linux-images-<board-name>` needs to be added to deb's `Provides` property using `SUPPORTED_BOARDS` variable in [`fork.conf`](./lbuild.md#forkconf).

Once you have both of them available, you can start building system image to test your kernel and U-Boot. Copy both files to `rbuild` folder (this folder will be mounted in `docker` so if those files are outside of `rbuild` folder the script won't be able to access them). Create `board-name.conf` under `configs`, with one line `SOC=system_on_chip_model` (model number in lower case). If you are adding Rockchip based device, their SoC name usually starts with `rk` and can be recognized by `common/hw-info.conf`. For non-standard name (Rockchip PX30, Amlogic based SoC), update `hw-info.conf`'s `get_soc_family` function. For entirely new vendor, you will also need to update `get_partition_type` function and review any mention of `soc_family` within the script.

Once you create the board config file (yes, it's that simple), run the following command:
```
./rbuild -r -d -k linux-image-board-name.deb -f u-boot-board-name.deb board-name
```

`-r` means reusing rootfs generated in previous run. This saves a lot of time when testing multiple devices or different kernels. `-d` means dropping into a debug shell if any step fails. `-k` and `-f` specify the custom kernel and **f**irmware (currently U-Boot) you are going to use. This will build a CLI image by default.

You can then test your image. Once you are sure your kernel and firmware are up to sniff, create new repos in `radxa-pkg` organization to automatically generate packages for them (or update the existing one), create new releases, and update `radxa-repo/apt` to include them in the apt repo. You can then build image without `-k` and `-f` options.

Now you can update `radxa-build` organization to have the image auto generated over there.